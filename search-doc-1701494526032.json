[{"title":"存储卡文件自动迁移方案","type":0,"sectionRef":"#","url":"/blog/COS","content":"","keywords":"","version":null},{"title":"说明​","type":1,"pageTitle":"存储卡文件自动迁移方案","url":"/blog/COS#说明","content":" 关键词​  COS：即Chip Operating System，这里特指安全芯片内操作系统。  TF卡：即外置存储卡，这里特指安全存储卡。  明区：即TF卡的普通存储区域，普通数据区。  密区：即TF卡的加密存储区域，安全数据区。  ExFAT：即Extended File Allocation Table File System，扩展FAT，即扩展文件分配表；是Microsoft在Windows的Embeded 5.0以上中引入的一种适合于闪存的文件系统，为了解决FAT32等不支持4G及其更大的文件而推出。对于闪存，NTFS文件系统不适合使用，ExFAT更为适用。这里作为本方案的上层TF卡文件系统。  ","version":null,"tagName":"h3"},{"title":"背景​","type":1,"pageTitle":"存储卡文件自动迁移方案","url":"/blog/COS#背景","content":" 当前场景对于安全TF卡核心需求为：  简单易用，操作简单无需学习，开箱即用；现有方案安全数据的均需安全工具软件才能访问，不能满足多平台，体验参差不齐。环境无痕，整个操作在系统中不留痕迹，无需安装软件或运行插件；当前安全数据访问需要安装或运行特定的软件或插件。  在原安全TF卡技术方案上解决以上需求，即是本方案的目标。  关于简单易用性，操作系统提供了最为简单友好的文件管理软件，因此本方案的关键点就是直接利用操作系统的文件管理软件，无需进行软件或插件的开发，即可达到数据安全存储的目的。    ","version":null,"tagName":"h3"},{"title":"技术方案​","type":1,"pageTitle":"存储卡文件自动迁移方案","url":"/blog/COS#技术方案","content":" 设计​    说明：  本方案解决了数据存储直接无需安装或运行软件或插件的问题。在保存数据场景中直接使用操作系统的文件管理进行操作，简单易用，无痕。在此场景下无需开发额外工具，只要操作系统文件管理可以访问标准的TF卡，即支持此安全功能。  硬件​  为了能够达到安全存储控制的目的，在传统的TF卡上增加安全芯片，其为ARM平台采用SD指令直接和TF卡进行通信，TF卡的数据加解密速度可达25MB/S以上。安全TF卡方案主要由：SD接口处理层、Nandflash管理层、COS、驱动四部分组成。其中COS主要包含：命令解析、数据识别、访问控制（授权认证）、加解密几个模块。    数据流​  当前主流方案为①至②的解决方案，密区的数据只能通过特定的接口进行访问。为了能够让密区的写命令也能借用普通命令通道，因此需要对写命令进行解析，并对目标数据进行重定向至密区。即方案升级为：②至③。    数据存储​  安全TF卡整个存储空间分布如下图所示：    1）MBR，即Master Boot Record。存储分区格式通常为MBR分区和GPT（GUID Partition Table）分区两种格式。MBR磁盘分区支持最大卷为2 TB（Terabytes）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器），这里安全TF卡采用MBR分区格式。    2）FAT表，本方案只有一个，FAT2只有定义TFAT才存在，本方案不涉及。  3）簇位图，是ExFAT文件系统中的第一个元文件，类似于NTFS文件系统中的元文件$BitMap，它的作用是用来管理分区中簇的使用情况。簇位图文件中的每一个位，映射到数据区中的每一个簇。如果某个簇分配给了文件，该簇在簇位图文件中对应的位就会被填入“1”，表示该簇已经占用；如果没有使用的空簇，它们在簇位图文件中对应的位就是“0”。  4）大写字符，是ExFAT文件系统中的第二个元文件，类似于NTFS文件系统中的元文件$UpCase。Unicode字母表中的每一个字符在这个文件中都有对应的条目，用于比较、排序、计算Hash值。  5）用户数据，即ExFAT文件系统根目录数据，具有如下特征：  分区中的每个文件及文件夹（也称为目录）都被分配多个大小为32字节的目录项，用以描述文件及文件夹的属性、大小、起始簇号和时间、日期等信息，当然还会把文件名或目录名也记录在目录项中。目录也被视为特殊类型的文件，所以每个目录也与文件一样有目录项。分区根目录下的文件及文件夹的目录项存放在根目录区中，分区子目录下的文件及文件夹的目录项存放在数据区相应的簇中。文件系统目录项的第一个字节用来描述目录项的类型，剩下的31个字节用来记录文件的相关信息。  6）隐藏区，属于加密区中的一部分，用于保存加密区数据的全局配置，如设备ID、认证ID、跟密钥也业务配置数据等。  7）密区用户数据，该数据按照自定义格式存储文件数据，格式为文件头和文件数据内容两部分。  解析和识别​  SD命令接口扩展​  拦截SD接口标准数据写命令，并且可以扩展修改数据存储的扇区和数据内容，如接口定义如下：  /** * @brief: 当用户在明区保存文件数据，ExFAT文件系统处理完成，落地明区磁盘之前的回调 * @param lba 数据起始扇区号（可重定向） * @param buf 数据缓存地址，该数据修改后则会影响到实际落地的数据 * @param blockNum 数据扇区数 * @return * 0: 成功, 否则操作失败，中断返回 * */ uint8_t tf_handleDataWrite(uint32_t* lba, uint8_t *buf, uint8_t* blockNum);   ExFAT文件系统头识别​  由于回调接口为底层磁盘扇区写操作接口，因此需要对传递过来的参数进行精准快速识别。需要在COS启动时对文件系统配置进行解析（如：簇大小，文件系统根目录偏移等）。因此首先需要了解Main Boot Region 主引导区Boot Sector（引导扇区）的数据结构。  偏移量\t大小\t描述\t内容0x00\t3\t跳转指令\tEB 76 90 0x03\t8\t文件系统名称\t&quot;EXFAT &quot; 0x0B\t53\t保留区\t全为0 0x40\t8\t隐藏扇区数 0x48\t8\t分区总扇区数 0x50\t4\tFAT表起始扇区号 0x54\t4\tFAT表扇区数 0x58\t4\t首簇起始扇区号 0x5C\t4\t分区内的总簇数\t最大值为2^32-11 0x60\t4\t根目录首簇号\t0x04只占1个簇 0x64\t4\t卷序列号\t4个字节的随机数 0x68\t2\t卷版本号\t固定为“00 01” 0x6A\t2\t卷状态\t固定为“00 00” 0x6C\t1\t每扇区字节数\t2^N(最小值为9à 2^9=512字节/扇区最大值为12à 2^12=4096字节/扇区) 0x6D\t1\t每簇扇区数\t2^N(最小值为0à 2^0=1扇区/簇最大值为25à 2^16=65536扇区/簇 = 32 MB) 0x6E\t1\tFAT表个数\t该值为1，只有对TExFAT才为2 0x6F\t1\t驱动标记\t这个是提供给INT13中断使用的，通常为80H 0x70\t1\t分区使用百分比\t0~100。百分之多少的簇已被分配。该值可不准确 0x71\t7\t保留\t00 0x78\t390\t引导程序\t固定值 0x1FE\t2\t引导结束标志\t0x55AA  说明：  通过跳转指令和文件系统名称可以定位到文件系统的起始扇区号。根据0x6C和0x6D可以获得每簇扇区数以及扇区字节数，用于文件数据内容扇区定位。  目标文件数据识别​  ExFAT文件系统中每个用户文件至少有三个目录项，这三个目录项被称为三个属性：第一个目录项称为“属性1”，目录项首字节的特征值为“85H”；第二个目录项称为“属性2”，目录项首字节的特征值为“C0H”；第三个目录项称为“属性3”，目录项首字节的特征值为“C1H”。  1）“属性1”目录项：  用来记录该目录项的附属目录项数、校验和、文件属性、时间戳等信息。其格式定义为：  偏移\t字段长度(字节)\t说明0x00\t1\t目录项的类型(特征值为“85H”) 0x01\t1\t附属目录项数 0x02\t2\t对所有属性项的Hash校验值 0x04\t2\t文件属性 0x06\t2\t保留 0x08\t4\t文件创建时间 0x0C\t4\t文件最后修改时间 0x10\t4\t文件最后访问时间 0x14\t1\t文件创建时间精确至10ms 0x15\t1\t文件最后修改时间精确至10ms 0x16\t1\t创建时间时区差，间隔15分钟 0x17\t1\t最后修改时间时区差，间隔15分钟 0x18\t1\t最后访问时间时区差，间隔15分钟 0x19\t7\t保留  该目录项可以识别目标文件的属性和起始目录项标识。  2）“属性2”目录项：  用来记录文件是否有碎片、文件名的字符数、文件名的Hash值、文件的起始簇号及大小等信息，格式定义如下：  偏移\t字段长度(字节)\t说明0x00\t1\t目录项的类型(特征值为“C0H”) 0x01\t1\t文件碎片标志。如果是连续存放没有碎片，该标志为“03H”；如果是不连续存放，文件有碎片，该标志就为“01H” 0x02\t1\t保留 0x03\t1\t文件名字符数N。用UNICODE码表示，每个字符占用2个字节 0x04\t2\t文件名Hash校验值。当文件名发生改变时，Hash值也会发生改变。 0x06\t2\t保留 0x08\t8\t文件大小1（文件的总字节数） 0x10\t4\t保留 0x14\t4\t起始簇号 0x18\t8\t文件大小2（备份值）。通常情况下与“文件大小1”的数值保持一致  通过属性2可以获取目标文件的大小和文件数据内容存储的起始簇号，通过起始簇号可以计算得到对应的扇区号，以及是否连续的特征。  3）“属性3”目录项：  用来具体记录文件的名称。如果文件名很长，“属性3”可以包含多个目录项，每个目录项称为一个片段，从上至下依次记录文件名的每一个字符。其格式定义为：  偏移\t字段长度(字节)\t说明0x00\t1\t目录项的类型(特征值为“C1H”) 0x01\t1\t保留 0x02\t2N\t文件名  通过属性3可以获取文件名称。  目标文件数据重定向​  为了能够实现数据重定向，首先需要了解SD扩展接口的特性：  底层接口每次传递数据大小为扇区整数倍。接口调用流程不可改变，否则会导致中断信号异常，上层文件系统运行错误，出现数据损坏的情况。因此在回调实现中，只能修改目标扇区位置以及本次待写入的数据内容。接口回调时若本次为连续扇区操作，则仅能在首次映射时进行重定向，后续的重定向将不能生效。  技术难点​  SD命令接口扩展（写）​  该接口在底层固件实现，使得在接收到数据存储命令后，落地磁盘扇区前，回调给COS进行业务处理，这是整个方案能力基础。在COS处理完后，再将数据写入指定扇区位置。保证流程不中断，运行稳定。  精准快速识别​  由于文件系统数据存储高效率要求，若COS中数据处理耗时，则会直接触发超时，系统提前终止写入。因此对方案高效且精准的数据识别非常高。  快速过滤非目标文件数据；在实际运行时，大量的磁盘读写操作与目标文件数据无关，因此需要快速返回，不影响正常使用。文件头和文件内容区别识别；通常目标文件头需要精准识别，在识别完文件头后，文件内容数据则通过计算的簇链扇区号即可快速判断其合法扇区号。通常文件头格式固定，而文件内容长度则可变且长度大大超过文件头数据，因此仅通过扇区号合法性判断可以加快数据处理，提升效率。  扇区重定向​  重定向需要解决文件头数据不在同一扇区的问题，由于两次的回调给数据的识别和修复带来很大的麻烦。需要将两次扇区，即前一扇区的尾部和后一扇区的头部数据合并识别和修复。    为了使得上层的文件系统运行稳定，而文件头数据通常处于扇区的某个片段位置，因此回调后需要继续往明区写入数据。为了达到数据保护的目的，需要将原始文件真实数据保存至密区后，还需要对明区的数据进行伪装。  伪装为其他文件名或文件夹伪装为空文件名伪装为已删除文件  为了达到文件头数据格式正确需要对各属性项的数据进行Hash校验，其生成Hash的实现为：  // 所有属性目录项的Hash值计算 unsigned short doEntrySetChecksumHash(unsigned char* octets, int NumberOfBytes) { unsigned short checksum = 0; int index; for (index = 0; index &lt; NumberOfBytes; index++) { if (index == 2 || index == 3) continue; checksum = ((checksum &lt;&lt;15) | (checksum&gt;&gt; 1)) + (unsigned short) octets[index]; } return checksum; } unsigned char toUpper(unsigned char ch) { return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' ? ch - 32 : ch; } // 属性2目录项中对属性3目录项中hash值计算 unsigned short doNameHash(uint8_t* name, uint8_t nameLen) { int i; unsigned short hash = 0, cc; for (i=0; i&lt;nameLen; i++) { cc = toUpper(*name ++); hash = (uint16_t)(((hash &lt;&lt; 15) | (hash &gt;&gt; 1)) + (cc &amp; 0x00ff)); hash = (uint16_t)(((hash &lt;&lt; 15) | (hash &gt;&gt; 1)) + ((cc &amp; 0xff00) &gt;&gt; 8)); } return hash; }   文件头复写​  通常ExFAT文件系统会对文件头（文件目录属性项）进行多次复写。文件目录或空文件则无第四步骤。  首次写入，则保存文件目录项格式（即属性1、属性2、属性3），不包含文件自身属性。二次写入，则包含文件部分属性，如文件夹或文档，原文件修改时间，文件名。三次写入，则包含本次文件创建时间，文件内容数据起始簇信息。四次写入，则包含实际写入的数据大小即文件大小。    因此在文件头解析过程中，需要对每次回调的数据进行解析和填充，确保加密的文件头数据正确无误。  簇链追踪​  文件目录项记录了文件内容数据的起始簇号，数据以对应扇区号（连续或不连续）依次写入磁盘。  FAT表区格式：  ExFAT的每个FAT项由4字节构成，也就是32位的表项。每个FAT项都有一个固定的编号，这个编号从0开始，也就是说，第一个FAT项是0号FAT项，第二个FAT项是1号FAT项，以此类推。每个FAT项占用4字节：其中0号FAT项描述介质类型，其首字节为“F8”，表示介质类型为硬盘；1号FAT项写入4个“FF”；从2号FAT项开始对应2号簇，3号FAT项开始对应3号簇，一直到最后一个簇。目前2、3、4三个FAT项中都是结束标志，簇位图文件、大写字符文件、根目录各占一个簇。分区的数据区中的每一个簇都会映射到FAT表中的唯一一个FAT项。因为0号FAT项和1号FAT项有特殊的用途，无法与数据区中的簇形成映射，所以数据区中的第一个簇也就编号为2号簇，这也是没有0号簇和1号簇的原因，然后3号簇与3号FAT项映射，4号簇与4号FAT项映射，以此类推。分区格式化后，分区的两个元文件（簇位图文件和大写字符文件）及用户文件都以簇为单位存放在数据区中，一个文件至少占用一个簇。当一个文件占用多个簇时，这些簇的簇号可能是连续的，也可能是不连续的。如果文件存放的簇不连续，这些簇的簇号就以簇链的形式登记在FAT表中；而如果文件存放在连续的簇中，FAT表则不登记这些连续的簇链。  综上，ExFAT文件系统FAT表的功能主要是登记不连续存储的文件的簇链，所以在FAT中可以看到数值为0的FAT项，并不能说明该FAT项对应的簇是可用簇。  1）1.txt文件占0x05、0x07号簇，2.txt占0x06号簇，FAT表如下：  2）1.txt文件占0x05、0x07号簇，2.txt占0x06、0x0B、0x0C号簇，3.txt文件占0x08、0x0A号簇，4.txt占0x09号簇，FAT表如下：  因此，在识别文件内容数据时，需要从起始簇开始，对照FAT记录的非连续簇关系，动态生成判断扇区号是否为目标文件数据的合法性条件。 ","version":null,"tagName":"h3"},{"title":"深入Binder拦截","type":0,"sectionRef":"#","url":"/blog/Binder","content":"","keywords":"","version":null},{"title":"说明​","type":1,"pageTitle":"深入Binder拦截","url":"/blog/Binder#说明","content":" Binder作为Android系统跨进程通信的核心机制。网上也有很多深度讲解该机制的文章，如：  Android跨进程通信详解Binder机制原理Android系统核心机制Binder【系列】  这些文章和系统源码可以很好帮助我们理解Binder的实现原理和设计理念，为拦截做准备。借助Binder拦截可以我们可以扩展出那些能力呢：  虚拟化的能力，多年前就出现的应用免安装运行类产品如：VirtualApp/DroidPlugin/平行空间/双开大师/应用分身等。测试验证的能力，通常为Framework层功能开发。检测第三方SDK或模块系统服务调用访问情况（特别是敏感API调用）。逆向分析应用底层服务接口调用实现。第三方ROM扩展Framework服务。  ","version":null,"tagName":"h3"},{"title":"现有方案​","type":1,"pageTitle":"深入Binder拦截","url":"/blog/Binder#现有方案","content":" 一直以来实时分析和拦截进程的Binder通信是通过Java层的AIDL接口代理来实现的。借助于Android系统Binder服务接口设计的规范，上层的接口均继承于IBinder。  如一下为代理目标对象的所有的接口API的方法：  import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; private static void getInterface(Class&lt;?&gt; cls, final HashSet&lt;Class&lt;?&gt;&gt; ss) { Class&lt;?&gt;[] ii; do { ii = cls.getInterfaces(); for (final Class&lt;?&gt; i : ii) { if (ss.add(i)) { getInterface(i, ss); } } cls = cls.getSuperclass(); } while (cls != null); } private static Class&lt;?&gt;[] getInterfaces(Class&lt;?&gt; cls) { final HashSet&lt;Class&lt;?&gt;&gt; ss = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(); getInterface(cls, ss); if (0 &lt; ss.size()) { return ss.toArray(new Class&lt;?&gt;[ss.size()]); } return null; } public static Object createProxy(Object org, InvocationHandler cb) { try { Class&lt;?&gt; cls = org.getClass(); Class&lt;?&gt;[] cc = getInterfaces(cls); return Proxy.newProxyInstance(cls.getClassLoader(), cc, cb); } catch (Throwable e) { Logger.e(e); } finally { // TODO release fix proxy name } return null; }   1、对于已经生成的Binder服务对象，在应用进程可参与实现逻辑之前就已经缓存了，我们需要找到并且进行替换（AMS、PMS、WMS等），如AMS在Android 8.0之后的缓存如下：  // source code: http://aospxref.com/android-9.0.0_r61/xref/frameworks/base/core/java/android/app/ActivityManager.java package android.app; public class ActivityManager { public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; }   因此我们需要找到并且替换它，如：  Object obj; if (Build.VERSION.SDK_INT &lt; 26) {// &lt;= 7.0 obj = ReflectUtils.getStaticFieldValue(&quot;android.app.ActivityManagerNative&quot;, &quot;gDefault&quot;); } else {// 8.0 &lt;= obj = ReflectUtils.getStaticFieldValue(&quot;android.app.ActivityManager&quot;, &quot;IActivityManagerSingleton&quot;); } Object inst = ReflectUtils.getFieldValue(obj, &quot;mInstance&quot;); ReflectUtils.setFieldValue(obj, &quot;mInstance&quot;, createProxy(inst));   2、对于后续运行过程中才获取的Binder服务，则需要代理ServiceManager，源码如下：  // source code: http://aospxref.com/android-9.0.0_r61/xref/frameworks/base/core/java/android/os/ServiceManager.java package android.os; public final class ServiceManager { private static final String TAG = &quot;ServiceManager&quot;; private static IServiceManager sServiceManager; }   因此我们的代理如下：  Class&lt;?&gt; cls = ReflectUtils.findClass(&quot;android.os.ServiceManager&quot;); Object org = ReflectUtils.getStaticFieldValue(cls, &quot;sServiceManager&quot;); Object pxy = new createProxy(org); if (null != pxy) { ReflectUtils.setStaticFieldValue(getGlobalClass(), &quot;sServiceManager&quot;, pxy); }   这样每次在第一次访问该服务时，就会调用IServiceManager中的getService的方法，而该方法已经被我们代理拦截，我们可以通过参数可以识别当前获取的是哪个服务，然后将获取的服务对象代理后在继续返回即可。  但是：这样的方案并不能拦截进程中所有的Binder服务。我们面临几大问题：  首先，Android源码越来越庞大，了解所有的服务工作量很大，因此有哪些服务已经被缓存排查非常困难。 其次，厂商越来越钟情于扩展自定义服务，这些服务不开源，识别和适配更加耗时。 再次，有一部分服务只有native实现，并不能通过Java层的接口代理进行拦截（如：Sensor/Audio/Video/Camera服务等）。 // source code: http://aospxref.com/android-13.0.0_r3/xref/frameworks/av/camera/ICamera.cpp class BpCamera: public BpInterface&lt;ICamera&gt; { public: explicit BpCamera(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;ICamera&gt;(impl) { } // start recording mode, must call setPreviewTarget first status_t startRecording() { ALOGV(&quot;startRecording&quot;); Parcel data, reply; data.writeInterfaceToken(ICamera::getInterfaceDescriptor()); remote()-&gt;transact(START_RECORDING, data, &amp;reply); return reply.readInt32(); } }   ","version":null,"tagName":"h3"},{"title":"新方案：基于底层拦截​","type":1,"pageTitle":"深入Binder拦截","url":"/blog/Binder#新方案基于底层拦截","content":" 原理​  我们都知道Binder在应用进程运行原理如下图：    不管是Java层还是native层的接口调用，最后都会通过ioctl函数访问共享内存空间，达到跨进程访问数据交换的目的。因此我们只要拦截ioctl函数，即可完成对所有Binder通信数据的拦截。底层拦截有以下优势：  1）可以拦截所有的Binder通信。  2）底层拦截稳定，高兼容性。从Android 4.x至Android 14，近10年的系统版本演进，涉及到Binder底层通信适配仅两次；一次是支持64位进程（当时需要同时兼容32位和64位进程访问Binder服务）。另一次是华为鸿蒙系统的诞生，华为ROM在Binder通信协议中增加了新的标识字段。  要解决的问题​  如何拦截​  C/C++层的函数拦截，并不像Java层一样系统提供了较为稳定的代理工具，在这里不是我们本期讨论的重点，可以直接采用网上开源的Hook框架：  https://github.com/bytedance/android-inline-hookhttps://github.com/bytedance/bhookhttps://github.com/asLody/whale  如何过滤​  ioctl函数为系统底层设备访问函数，调用及其频繁，而Binder通信调用只是其中调用者之一，因此需要快速识别非Binder通信调用，不影响程序性能。  函数定义：  #include &lt;sys/ioctl.h&gt; int ioctl(int fildes, unsigned long request, ...);   request的参数定义：  // source code: http://aospxref.com/android-14.0.0_r2/xref/bionic/libc/kernel/uapi/linux/android/binder.h #define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read) #define BINDER_SET_IDLE_TIMEOUT _IOW('b', 3, __s64) #define BINDER_SET_MAX_THREADS _IOW('b', 5, __u32) #define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, __s32) #define BINDER_SET_CONTEXT_MGR _IOW('b', 7, __s32) #define BINDER_THREAD_EXIT _IOW('b', 8, __s32) #define BINDER_VERSION _IOWR('b', 9, struct binder_version) #define BINDER_GET_NODE_DEBUG_INFO _IOWR('b', 11, struct binder_node_debug_info) #define BINDER_GET_NODE_INFO_FOR_REF _IOWR('b', 12, struct binder_node_info_for_ref) #define BINDER_SET_CONTEXT_MGR_EXT _IOW('b', 13, struct flat_binder_object) #define BINDER_FREEZE _IOW('b', 14, struct binder_freeze_info) #define BINDER_GET_FROZEN_INFO _IOWR('b', 15, struct binder_frozen_status_info) #define BINDER_ENABLE_ONEWAY_SPAM_DETECTION _IOW('b', 16, __u32) #define BINDER_GET_EXTENDED_ERROR _IOWR('b', 17, struct binder_extended_error)   对应的源码：  // source code: http://aospxref.com/android-14.0.0_r2/xref/frameworks/native/libs/binder/IPCThreadState.cpp void IPCThreadState::threadDestructor(void *st) { ioctl(self-&gt;mProcess-&gt;mDriverFD, BINDER_THREAD_EXIT, 0); } status_t IPCThreadState::getProcessFreezeInfo(pid_t pid, uint32_t *sync_received, uint32_t *async_received) { return ioctl(self()-&gt;mProcess-&gt;mDriverFD, BINDER_GET_FROZEN_INFO, &amp;info); } status_t IPCThreadState::freeze(pid_t pid, bool enable, uint32_t timeout_ms) { return ioctl(self()-&gt;mProcess-&gt;mDriverFD, BINDER_FREEZE, &amp;info) &lt; 0); } void IPCThreadState::logExtendedError() { ioctl(self()-&gt;mProcess-&gt;mDriverFD, BINDER_GET_EXTENDED_ERROR, &amp;ee) &lt; 0); } status_t IPCThreadState::talkWithDriver(bool doReceive) { // 实际Binder调用通信 return ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr); }   快速过滤：  static int ioctl_hook(int fd, int cmd, void* arg) { if (cmd != BINDER_WRITE_READ || !arg || g_ioctl_disabled) { return g_ioctl_func(fd, cmd, arg); } }   如何解析​  目标源码：http://aospxref.com/android-14.0.0_r2/xref/frameworks/native/libs/binder  重点解析发送（即BC_TRANSACTION和BC_REPLY）和接收（即BR_TRANSACTION和BR_REPLY）的类型数据。  如何修改数据​  修改数据分为以下几种：  1）修复调用时参数数据。  2）修复调用后返回的结果数据。  如果数据修复不改变当前数据的长度，只是内容的变化，则可以直接通过地址进行修改。否则需要创建新的内存进行修改后将新的数据地址设置到BINDER_WRITE_READ结构的buffer成员。此时处理好内存的释放问题。  3）直接拦截本次调用。  为了保障稳定性，不打断Binder的调用流程（通常这也是拦截和逆向方案保障稳定的最重要原则之一）。我们可以将目标函数code修改成父类处理的通用方法，然后通过修复调用的返回值即可完成拦截。  ","version":null,"tagName":"h3"},{"title":"方案实现​","type":1,"pageTitle":"深入Binder拦截","url":"/blog/Binder#方案实现","content":" 数据解析​  Binder调用数据结构如下：    解析bwr​  bwr即binder_write_read，从源码中了解到ioctl的BINDER_WRITE_READ类型的arg数据结构为：  struct binder_write_read { // 调用时传入的数据 binder_size_t write_size;// call data binder_size_t write_consumed;// call data binder_uintptr_t write_buffer;// call data // 结果返回数据 binder_size_t read_size;// recv data binder_size_t read_consumed;// recv data binder_uintptr_t read_buffer;// recv data };   不管是传入还是返回的数据，都是一组BC命令或BR命令，也就是说一次调用上层会打包几个命令一起传递。因此我们需要通过循环来找到我们的命令。  void binder_find_for_bc(struct binder_write_read&amp; bwr) { binder_uintptr_t cmds = bwr.write_buffer; binder_uintptr_t end = cmds + (binder_uintptr_t)bwr.write_size; binder_txn_st* txn = NULL; while (0 &lt; cmds &amp;&amp; cmds &lt; end &amp;&amp; !txn) { // 由于每次Binder通信数据量的限制，Binder设计每次调用有且仅包含一个有效的参数命令，因此只要找到即可，其他类型则直接跳过忽略 cmds = binder_parse_cmds_bc(cmds, txn); } }   dump数据如下：  write_buffer:0xb400007107d1d400, write_consumed:68, write_size:68 00000000: 00 63 40 40 14 00 00 00 00 00 00 00 00 00 00 00 .c@@............ 00000010: 00 00 00 00 01 00 00 00 12 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 ....T........... 00000030: 00 00 00 00 00 4d 3a ac 70 00 00 b4 00 00 00 00 .....M:.p....... 00000040: 00 00 00 00 .... BR_NOOP: 0x720c BR_TRANSACTION_COMPLETE: 0x7206 BR_REPLY: 0   解析txn​  txn即binder_transaction_data，Binder方法调用的方法参数信息定义如下：  struct binder_transaction_data { union { __u32 handle; binder_uintptr_t ptr; } target;// 目标服务句柄，server端使用 binder_uintptr_t cookie;// 缓存的Binder进行访问 __u32 code;//方法编号 __u32 flags;// 标识，如是否为 oneway __s32 sender_pid; __u32 sender_euid; binder_size_t data_size;// 数据长度 binder_size_t offsets_size;// 若包含对象，则对象数据大小 union { struct { binder_uintptr_t buffer;// Binder方法参数值地址 binder_uintptr_t offsets;// Binder方法参数对象数据地址 } ptr; __u8 buf[8]; } data; };   dumo数据如下：  Trace : target: 1 cookie: 0 code: 23 flags: 0x12(READ REPLY) Trace : pid: 0 uid: 0 size: 196 offs:8 Trace : 00000000: 00 00 00 80 ff ff ff ff 54 53 59 53 1c 00 00 00 ........TSYS.... Trace : 00000010: 61 00 6e 00 64 00 72 00 6f 00 69 00 64 00 2e 00 a.n.d.r.o.i.d... Trace : 00000020: 61 00 70 00 70 00 2e 00 49 00 41 00 63 00 74 00 a.p.p...I.A.c.t. Trace : 00000030: 69 00 76 00 69 00 74 00 79 00 4d 00 61 00 6e 00 i.v.i.t.y.M.a.n. Trace : 00000040: 61 00 67 00 65 00 72 00 00 00 00 00 85 2a 62 73 a.g.e.r......*bs Trace : 00000050: 13 01 00 00 00 38 dd 2a 71 00 00 b4 00 05 e9 31 .....8.*q......1 Trace : 00000060: 71 00 00 b4 01 00 00 0c 1a 00 00 00 63 00 6f 00 q...........c.o. Trace : 00000070: 6d 00 2e 00 69 00 66 00 6d 00 61 00 2e 00 74 00 m...i.f.m.a...t. Trace : 00000080: 72 00 61 00 6e 00 73 00 65 00 63 00 2e 00 63 00 r.a.n.s.e.c...c. Trace : 00000090: 6f 00 6e 00 74 00 61 00 69 00 6e 00 65 00 72 00 o.n.t.a.i.n.e.r. Trace : 000000a0: 00 00 00 00 08 00 00 00 73 00 65 00 74 00 74 00 ........s.e.t.t. Trace : 000000b0: 69 00 6e 00 67 00 73 00 00 00 00 00 00 00 00 00 i.n.g.s......... Trace : 000000c0: 01 00 00 00 .... Trace : binder object offs:0x4c type:0x73622a85 flags:0x113 ptr:0x2add3800 cookie:0x31e90500   解析服务名​  Binder通信数据头如下，即可解析出目标服务名：  void find_server_name(const binder_txn_st* txn) { const int32_t* ptr = reinterpret_cast&lt;const int32_t*&gt;(txn-&gt;data.ptr.buffer); ++ ptr;// skip strict model if (29 &lt;= sdkVersion()) ++ ptr;// 10.0 &lt;=, skip flags(ff ff ff ff) int32_t nameLen = *ptr; const uint16_t* name16 = (const uint16_t*)(ptr+1); }   解析方法名​  Binder通信数据中标识该服务方法的参数是txn-&gt;code。AIDL定义类在编译后会为每个方法自动生成静态的方法。  如定义的Binder接口方法为：  interface IDemo { void test(); void test2(); }   则编译后生成的类为：  class IDemo$Stub { void test(); void test2(); static final int TRANSACTION_test = 1; static final int TRANSACTION_test2 = 2; }   因此我们可以通过反射的方式，找到服务名对应的类所有静态成员变量，然后找到与code值相等的成员即为此方法。  这里可能需要解决私有API的限制解除问题。  // 可直接使用工程工具类 TstClassPrinter.printStubByCodes(&quot;android.app.IActivityManager&quot;, 13, 16, 67);   日志输出如下：    解析数据​  首先需要借助数据封装类Parcel。  // souce code: // http://aospxref.com/android-14.0.0_r2/xref/frameworks/native/include/binder/Parcel.h // http://aospxref.com/android-14.0.0_r2/xref/frameworks/native/libs/binder/Parcel.cpp   借助该类可以解析一些比较简单的数据，快速的找到目标内容。而对于比较复杂的数据，如参数值为Intent，该参数类型嵌套了多层的Parcelable成员，因此在native层通过Parcel来解析，兼容性比较差。因此我们选择通过回调到Java层来解析，修改后再格式化为native的buffer数据。这里需要处理好Java和native层的数据交换问题，以及回收。  native层：  // 创建 jobject obtain(JNIEnv* env) { jclass jcls = env-&gt;FindClass(&quot;android/os/Parcel&quot;); jmethodID method = env-&gt;GetStaticMethodID(jcls, &quot;obtain&quot;, &quot;()Landroid/os/Parcel;&quot;); if (!method) return NULL; mParcelObj = env-&gt;CallStaticObjectMethod(jcls, method); if (!mParcelObj) return NULL; if (0 &lt; mUparcel-&gt;dataSize()) { method = env-&gt;GetMethodID(sParcelClass, &quot;setDataPosition&quot;, &quot;(I)V&quot;); if (method) { unmarshall(env, mUparcel-&gt;data(), mUparcel-&gt;dataSize()); env-&gt;CallVoidMethod(mParcelObj, method, mUparcel-&gt;dataPosition()); } } return mParcelObj; } // 回收 void recycle(JNIEnv* env) { jclass jcls = env-&gt;FindClass(&quot;android/os/Parcel&quot;); jmethodID method = env-&gt;GetMethodID(jcls, &quot;recycle&quot;, &quot;()V&quot;); if (method) { env-&gt;CallVoidMethod(mParcelObj, method); } if (mParcelObj) { env-&gt;DeleteLocalRef(mParcelObj); } mParcelObj = NULL; }   Java层：  public static void clearHttpLink(Parcel p/*IN*/, Parcel q/*OUT*/) { try { Intent ii = Intent.CREATOR.createFromParcel(pp); // TODO something ... // write new data q.appendFrom(p, p.dataPosition(), p.dataAvail()); } catch (Throwable e) { e.printStackTrace(); } }   数据拦截​  Binder的数据解析和打印不会改变原数据内容，因此相对简单，如果要对数据进行修改，则相对复杂一些。修复的数据需要替换原数据，因此需要进行如下操作。  1、数据替换。  将txn中方法参数的数据指针指向新创建的数据区。   int binder_replace_txn_for_br(binder_txn_st *txn, ParcelEx* reply, binder_size_t _pos) { size_t size = reply-&gt;ipcDataSize(); uint8_t* repData = (uint8_t*)malloc(size + txn-&gt;offsets_size); memcpy(repData, reply-&gt;data(), size); if (0 &lt; txn-&gt;offsets_size) { binder_replace_objects(txn, repData, _pos, ((int)size) - ((int)(txn-&gt;data_size))); } txn-&gt;data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(repData); txn-&gt;data_size = size; return 0; }   2、修正对象指针。  如果传入的参数包含Binder对象，如register方法的Observe。因此修复的数据可能导致偏移的地址前移或者后移，因此需要重新计算偏移，如：  void replaceObjects(binder_txn_st *txn, uint8_t* objData, binder_size_t _pos, int _off) { binder_size_t* offs = reinterpret_cast&lt;binder_size_t*&gt;(txn-&gt;data.ptr.offsets); unsigned count = txn-&gt;offsets_size / sizeof(binder_size_t); while (0 &lt; count--) { if (0 != memcmp(objData + (int)(*offs), (uint8_t*)txn-&gt;data.ptr.buffer + (int)(*offs), sizeof(binder_size_t))) { *offs += _off; } ++ offs; } }   3、内存释放。  需要保存原地址A和新的地址AA的映射关系到自定义的内存池中。  当Binder通信命令出现BC_FREE_BUFFER和BR_FREE_BUFFER时，则通过该命令要释放的AA地址，然后从内存池找到与之对应A的地址，并设置回去让上层继续释放，完成内存使用的闭环。  case BC_FREE_BUFFER: { uintptr_t* buffPtr = (uintptr_t *)cmd; uintptr_t ptr = MemPool::detach(*buffPtr); if (__UNLIKELY(0 != ptr)) { *buffPtr = ptr;// set origin buffer } cmd += sizeof(uintptr_t);// move to next command } break;   ","version":null,"tagName":"h3"},{"title":"附：​","type":1,"pageTitle":"深入Binder拦截","url":"/blog/Binder#附","content":" 如果你有需要，可以直接使用我们已经封装好的SDK来实现相应的功能，该项目已经开源，链接地址如下：  Gitee  Github ","version":null,"tagName":"h3"}]